#!/usr/bin/python3

import argparse
try:
    from roypypack import roypy  # package installation
except ImportError:
    import roypy  # local installation
import queue
import sys
import threading
from sample_camera_info import print_camera_info
from roypy_sample_utils import CameraOpener, add_camera_opener_options
from roypy_platform_utils import PlatformHelper

import numpy as np
import cv2
import matplotlib.pyplot as plt

class MyListener(roypy.IDepthDataListener):
    def __init__(self, q):
        super(MyListener, self).__init__()
        self.frame = 0
        self.done = False
        self.undistortImage = False
        self.lock = threading.Lock()
        self.once = False
        self.queue = q
        self.cameraMatrix = None
        self.distortionCoefficients = None

    def onNewData(self, data):
        p = data.npoints()
        self.queue.put(p)

    def paint(self, data):
        self.lock.acquire()

        depth = data[:, :, 2]
        gray = data[:, :, 3]
        confidence = data[:, :, 4]

        zImage = self.adjustZValue(depth, confidence)
        grayImage = self.adjustGrayValue(gray)

        zImage8 = np.uint8(zImage)
        grayImage8 = np.uint8(grayImage)

        if self.undistortImage:
            zImage8 = cv2.undistort(zImage8, self.cameraMatrix, self.distortionCoefficients)
            grayImage8 = cv2.undistort(grayImage8, self.cameraMatrix, self.distortionCoefficients)

        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 5))
        ax1.imshow(zImage8, cmap='gray')
        ax1.set_title('Depth Image')
        ax1.axis('off')
        ax2.imshow(grayImage8, cmap='gray')
        ax2.set_title('Gray Image')
        ax2.axis('off')

        plt.figure(figsize=(5, 5))
        plt.imshow(zImage8, cmap='gray')
        plt.title('Select Waypoint')
        plt.axis('off')
        plt.tight_layout()

        def on_click(event):
            if event.inaxes == ax1:
                x = int(event.xdata)
                y = int(event.ydata)
                print(f"Selected point: x={x}, y={y}")
                # Perform waypoint computation and visualization here
                # You can plot waypoints using plt.scatter or other methods
                plt.scatter(x, y, color='red', marker='x', s=50)  # Example: Mark selected point
                plt.draw()  # Redraw the plot

        cid = fig.canvas.mpl_connect('button_press_event', on_click)

        plt.show()

        self.lock.release()
        self.done = True

    def setLensParameters(self, lensParameters):
        self.cameraMatrix = np.zeros((3, 3), np.float32)
        self.cameraMatrix[0, 0] = lensParameters['fx']
        self.cameraMatrix[0, 2] = lensParameters['cx']
        self.cameraMatrix[1, 1] = lensParameters['fy']
        self.cameraMatrix[1, 2] = lensParameters['cy']
        self.cameraMatrix[2, 2] = 1

        self.distortionCoefficients = np.zeros((1, 5), np.float32)
        self.distortionCoefficients[0, 0] = lensParameters['k1']
        self.distortionCoefficients[0, 1] = lensParameters['k2']
        self.distortionCoefficients[0, 2] = lensParameters['p1']
        self.distortionCoefficients[0, 3] = lensParameters['p2']
        self.distortionCoefficients[0, 4] = lensParameters['k3']

    def toggleUndistort(self):
        self.lock.acquire()
        self.undistortImage = not self.undistortImage
        self.lock.release()

    def adjustZValue(self, depth, confidence):
        clampedDist = np.minimum(2.5, depth)
        newZValue = clampedDist / 2.5 * 255
        return newZValue

    def adjustGrayValue(self, gray):
        clampedVal = np.minimum(600, gray)
        newGrayValue = clampedVal / 600 * 255
        return newGrayValue

def process_event_queue(q, painter):
    while True:
        try:
            item = q.get(True, 1)
        except queue.Empty:
            break
        else:
            painter.paint(item)
            currentKey = cv2.waitKey(1)
            if currentKey == ord('d'):
                painter.toggleUndistort()
            if currentKey == 27:
                break

def main():
    platformhelper = PlatformHelper()
    parser = argparse.ArgumentParser(usage=__doc__)
    add_camera_opener_options(parser)
    options = parser.parse_args()

    opener = CameraOpener(options)

    try:
        cam = opener.open_camera()
    except:
        print("could not open Camera Interface")
        sys.exit(1)

    try:
        replay = cam.asReplay()
        print("Using a recording")
        print("Framecount : ", replay.frameCount())
        print("File version : ", replay.getFileVersion())
    except SystemError:
        print("Using a live camera")

    q = queue.Queue()
    l = MyListener(q)
    cam.registerDataListener(l)
    cam.startCapture()

    lensP = cam.getLensParameters()
    l.setLensParameters(lensP)

    process_event_queue(q, l)

    cam.stopCapture()
    print("Done")

if __name__ == "__main__":
    main()
